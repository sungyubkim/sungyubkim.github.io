<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Flash Attention 2 | Sung-Yub Kim </title> <meta name="author" content="Sung-Yub Kim"> <meta name="description" content="FlashAttention-2 doubles training speed through better work partitioning, reduced non-matmul FLOPs, and improved parallelism."> <meta name="keywords" content="machine-learning, deep-learning, llm, foundation-models, research"> <meta property="og:site_name" content="Sung-Yub Kim"> <meta property="og:type" content="article"> <meta property="og:title" content="Sung-Yub Kim | Flash Attention 2"> <meta property="og:url" content="https://sungyubkim.github.io/blog/fa2/"> <meta property="og:description" content="FlashAttention-2 doubles training speed through better work partitioning, reduced non-matmul FLOPs, and improved parallelism."> <meta property="og:locale" content="en"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Flash Attention 2"> <meta name="twitter:description" content="FlashAttention-2 doubles training speed through better work partitioning, reduced non-matmul FLOPs, and improved parallelism."> <script type="application/ld+json">
    {
        "author":
        {
            "@type": "Person",
            "name": "Sung-Yub Kim"
        },
        "url": "https://sungyubkim.github.io/blog/fa2/",
        "@type": "BlogPosting",
        "description": "FlashAttention-2 doubles training speed through better work partitioning, reduced non-matmul FLOPs, and improved parallelism.",
        "headline": "Flash Attention 2",
        
        "sameAs": ["https://github.com/sungyubkim","https://scholar.google.com/citations?user=m2rhgrkAAAAJ","https://www.linkedin.com/in/sung-yub-kim-0a82a1264","https://twitter.com/SungyubK"],
        
        "name": "Sung-Yub Kim",
        "@context": "https://schema.org"
    }
  </script> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' data: https:; media-src 'self' https:; frame-src 'self' https:; connect-src 'self' https:;"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?v=6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%A7%A0&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sungyubkim.github.io/blog/fa2/"> <script src="/assets/js/theme.js?v=48c9b5bd7f2e0605e39e579400e22553"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Sung-Yub</span> Kim </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="fa-solid fa-magnifying-glass"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-half-sun-moon" id="light-toggle-system"></i> <i class="fa-solid fa-moon" id="light-toggle-dark"></i> <i class="fa-solid fa-sun" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Flash Attention 2</h1> <p class="post-meta"> Created on June 03, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/attention"> <i class="fa-solid fa-hashtag fa-sm"></i> attention</a>   <a href="/blog/tag/flash-attention"> <i class="fa-solid fa-hashtag fa-sm"></i> flash-attention</a>   <a href="/blog/tag/memory-efficiency"> <i class="fa-solid fa-hashtag fa-sm"></i> memory-efficiency</a>   <a href="/blog/tag/inference"> <i class="fa-solid fa-hashtag fa-sm"></i> inference</a>   <a href="/blog/tag/hardware-optimization"> <i class="fa-solid fa-hashtag fa-sm"></i> hardware-optimization</a>   <a href="/blog/tag/performance-scaling"> <i class="fa-solid fa-hashtag fa-sm"></i> performance-scaling</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="tldr">TL;DR</h1> <blockquote> <p><strong>이 논문은 무엇에 관한 것인가?</strong> FlashAttention-2는 AI 모델(특히 ChatGPT와 같은 대형 언어 모델)을 <strong>2배 더 빠르게</strong> 훈련하고 실행하면서 <strong>메모리 사용량을 획기적으로 줄이는</strong> 돌파구 알고리즘입니다. 마치 거대한 도서관에서 책을 찾는 더 효율적인 방법을 찾는 것과 같습니다 - 모든 책을 개별적으로 확인하는 대신, 작업 메모리에 맞는 스마트한 청크로 검색을 구성하는 방식입니다.</p> <p><strong>핵심 기여점:</strong></p> <ol> <li> <strong>성능 향상</strong>: 이전 FlashAttention보다 2배, 표준 방법보다 최대 9배 빠름</li> <li> <strong>하드웨어 최적화</strong>: GPU 이론적 최대치의 73% 달성 (이전 25-40%에서 향상)</li> <li> <strong>메모리 효율성</strong>: 긴 시퀀스에서 42배 메모리 사용량 감소 가능</li> <li> <strong>경제적 영향</strong>: 대형 모델 훈련 비용을 90% 절감 (GPT-3 규모의 경우 460만 달러에서 45만 달러로)</li> <li> <strong>세 가지 스마트 최적화</strong>: <ul> <li>비용이 많이 드는 비행렬 연산 감소</li> <li>GPU 코어 전반의 향상된 병렬화</li> <li>프로세서 간 낭비적인 메모리 통신 제거</li> </ul> </li> </ol> <p><strong>이것이 중요한 이유:</strong> 이 작업은 계산 비용과 메모리 요구사항을 획기적으로 줄여 더 많은 연구자와 회사가 고급 AI에 접근할 수 있게 만듭니다. 마차에서 스포츠카로 업그레이드하는 것과 같습니다 - 같은 목적지이지만 훨씬 더 효율적입니다.</p> </blockquote> <ul> <li><a href="https://arxiv.org/pdf/2307.08691" rel="external nofollow noopener" target="_blank">Paper Link</a></li> </ul> <hr> <h1 id="related-papers">Related Papers</h1> <p><strong>FlashAttention 시리즈:</strong></p> <ul> <li> <a href="/blog/fa/">FlashAttention</a> - 원조 IO-aware 어텐션 알고리즘과 타일링 기법의 기초</li> <li> <a href="/blog/fa3/">FlashAttention-3</a> - 비대칭 어텐션과 FP8 지원으로 한층 발전된 버전</li> <li> <a href="https://courses.cs.washington.edu/courses/cse599m/23sp/notes/flashattn.pdf" rel="external nofollow noopener" target="_blank">From Online Softmax to FlashAttention</a> - 온라인 소프트맥스의 이론적 기초와 수치 안정성</li> </ul> <p><strong>하드웨어 최적화 및 시스템 연구:</strong></p> <ul> <li> <a href="/blog/sp/">Reducing Activation Recomputation in Large Transformer Models</a> - 메모리 효율적인 병렬 훈련 기법</li> <li> <a href="/blog/usp/">USP</a> - 통합 시퀀스 병렬화 프레임워크와의 상호작용</li> <li> <a href="/blog/tp/">Tensor Parallelism</a> - 텐서 병렬화와 FlashAttention의 결합 전략</li> <li> <a href="/blog/pp/">GPipe</a> - 파이프라인 병렬화와의 통합 방법론</li> </ul> <hr> <h1 id="takeaways">Takeaways</h1> <h3 id="1-동기-왜-이-연구가-필요했는가">1. 동기: 왜 이 연구가 필요했는가?</h3> <p><strong>핵심 문제: 어텐션은 비싸다</strong></p> <p>방대한 도서관에서 모든 책 쌍 사이의 연결을 찾아야 하는 사서라고 상상해보세요. 1,000권의 책이 있다면 1,000,000번의 비교(1,000²)가 필요합니다. 10,000권이라면 100,000,000번의 비교가 필요합니다. 이것이 바로 AI 어텐션 메커니즘에서 일어나는 일입니다 - 계산 비용이 입력 길이의 제곱에 비례하여 증가합니다.</p> <p><strong>FlashAttention-2 이전의 실제 영향:</strong></p> <ul> <li> <strong>메모리 위기</strong>: 4K 단어 시퀀스의 표준 어텐션에는 67GB 메모리가 필요하지만, 대부분의 GPU는 총 40-80GB만 가지고 있음</li> <li> <strong>속도 병목</strong>: 어텐션 연산은 GPU 능력의 25-40%만 활용하고 있었음</li> <li> <strong>경제적 장벽</strong>: 대형 모델 훈련에 수백만 달러가 소요되어 AI 연구를 거대 기술 기업으로 제한</li> </ul> <p><strong>저자들의 핵심 통찰:</strong> 이미 주요 돌파구였던 FlashAttention-1조차도 현대 GPU 아키텍처를 완전히 활용하지 못하고 있어 여전히 비효율적이라는 것을 깨달았습니다. 포뮬러 1 자동차를 가지고 있지만 시내 교통에서만 사용하는 것과 같습니다 - 전체 잠재력을 활용하지 못하고 있었습니다.</p> <h3 id="2-기술적-분석-병목-현상-이해하기">2. 기술적 분석: 병목 현상 이해하기</h3> <p><strong>프로파일링으로 드러난 세 가지 핵심 문제:</strong></p> <ol> <li> <p><strong>비행렬 연산이 16배 더 비싸다</strong></p> <ul> <li>현대 GPU는 행렬 곱셈에 최적화된 특수 “텐서 코어”를 가지고 있음</li> <li>A100 GPU: 행렬 연산 312 TFLOPs/s vs 기타 연산 19.5 TFLOPs/s</li> <li>FlashAttention-1은 비싼 비행렬 연산을 너무 많이 수행하고 있었음</li> </ul> </li> <li> <p><strong>긴 시퀀스에 대한 GPU 활용도 부족</strong></p> <ul> <li>GPU는 108개의 스트리밍 멀티프로세서가 모두 바쁠 때 최고 성능 발휘</li> <li>긴 시퀀스는 종종 작은 배치 크기를 의미하여 많은 프로세서가 유휴 상태</li> <li>108차선 고속도로가 있지만 16차선만 사용하는 것과 같음</li> </ul> </li> <li> <p><strong>낭비적인 메모리 통신</strong></p> <ul> <li>GPU 프로세서들이 느린 공유 메모리를 통해 끊임없이 서로 통신</li> <li>작업자들이 정보를 공유하기 위해 공장 바닥을 계속 걸어다니는 것과 같음</li> </ul> </li> </ol> <h3 id="3-핵심-가정과-성공-조건">3. 핵심 가정과 성공 조건</h3> <p><strong>FlashAttention-2가 작동하기 위한 중요한 요구사항:</strong></p> <p><strong>하드웨어 가정:</strong></p> <ul> <li> <strong>현대 GPU 아키텍처</strong>: 텐서 코어가 있는 Ampere/Hopper GPU(A100, H100) 필요</li> <li> <strong>충분한 고속 메모리</strong>: 적절한 SRAM 필요 (A100에서 스트리밍 멀티프로세서당 192KB)</li> <li> <strong>높은 메모리 대역폭</strong>: 최적 성능을 위해 &gt;1TB/s 메모리 대역폭 필요</li> </ul> <p><strong>알고리즘 가정:</strong></p> <ul> <li> <strong>블록 친화적 시퀀스</strong>: 시퀀스 길이가 블록 크기(64, 128, 256)로 나누어떨어질 때 최고 성능</li> <li> <strong>수치 정밀도</strong>: fp16/bf16 정밀도 필요 - fp32로는 효율적으로 작동하지 않음</li> <li> <strong>메모리 계층 인식</strong>: 어텐션 블록을 고속 SRAM에 맞출 수 있어야 함</li> </ul> <p><strong>모델 제약:</strong></p> <ul> <li> <strong>헤드 차원 제한</strong>: 최대 256 헤드 차원 지원 (FlashAttention-1의 128에서 확장)</li> <li> <strong>시퀀스 길이</strong>: 이론적 제한 없음, 하지만 사용 가능한 메모리에 따른 실용적 제한</li> </ul> <p><strong>내 분석:</strong> 이러한 가정들은 FlashAttention-2를 매우 강력하게 만들지만 동시에 어느 정도 제한적이기도 합니다. 현대 하드웨어에 고도로 최적화되어 있지만 구형 GPU나 다른 아키텍처에서는 이점을 제공하지 않을 것입니다. 이는 시스템 연구에서 흔한 트레이드오프입니다 - 특정 하드웨어에 특화함으로써 성능을 얻는 것입니다.</p> <h3 id="4-flashattention-2-방법-실제-작동-원리">4. FlashAttention-2 방법: 실제 작동 원리</h3> <p><strong>개요: 세 가지 최적화 전략</strong></p> <p>FlashAttention-2를 식당 주방 최적화로 생각해보세요:</p> <ol> <li> <strong>준비 작업 줄이기</strong> (비행렬 연산 감소)</li> <li> <strong>더 나은 직원 배치</strong> (향상된 병렬화)</li> <li> <strong>주방 간 소통 제거</strong> (최적화된 작업 분할)</li> </ol> <h4 id="최적화-1-비행렬-연산-감소">최적화 1: 비행렬 연산 감소</h4> <p><strong>문제:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># FlashAttention-1: 비싼 재스케일링 연산들
</span><span class="k">def</span> <span class="nf">online_softmax_v1</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">prev_max</span><span class="p">,</span> <span class="n">prev_sum</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">많은 비싼 연산이 있는 원래 버전</span><span class="sh">"""</span>
    <span class="n">new_max</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">prev_max</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># ❌ 여러 개의 비싼 재스케일링 연산들
</span>    <span class="n">exp_prev</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">prev_max</span> <span class="o">-</span> <span class="n">new_max</span><span class="p">)</span>  <span class="c1"># 비싸다!
</span>    <span class="n">prev_sum_rescaled</span> <span class="o">=</span> <span class="n">exp_prev</span> <span class="o">*</span> <span class="n">prev_sum</span>   <span class="c1"># 비싸다!
</span>    <span class="n">exp_curr</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">scores</span> <span class="o">-</span> <span class="n">new_max</span><span class="p">)</span>    <span class="c1"># 비싸다!
</span>    <span class="n">curr_sum</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">exp_curr</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># 비싸다!
</span>    
    <span class="c1"># ❌ 더 많은 비싼 연산들
</span>    <span class="n">new_sum</span> <span class="o">=</span> <span class="n">prev_sum_rescaled</span> <span class="o">+</span> <span class="n">curr_sum</span>
    <span class="k">return</span> <span class="n">exp_curr</span><span class="p">,</span> <span class="n">new_max</span><span class="p">,</span> <span class="n">new_sum</span>
</code></pre></div></div> <p><strong>해결책:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># FlashAttention-2: 연산 감소로 최적화된 버전
</span><span class="k">def</span> <span class="nf">online_softmax_v2</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">prev_max</span><span class="p">,</span> <span class="n">prev_sum</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">전략적 연산 감소로 최적화된 버전</span><span class="sh">"""</span>
    <span class="n">curr_max</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">new_max</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">prev_max</span><span class="p">,</span> <span class="n">curr_max</span><span class="p">)</span>
    
    <span class="c1"># ✅ 스마트한 조건부 로직으로 연산 감소
</span>    <span class="k">if</span> <span class="n">torch</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="n">new_max</span><span class="p">,</span> <span class="n">curr_max</span><span class="p">):</span>
        <span class="c1"># 현재 최댓값이 전역 최댓값 - 이 경우에 최적화
</span>        <span class="n">exp_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">scores</span> <span class="o">-</span> <span class="n">new_max</span><span class="p">)</span>
        <span class="n">exp_prev_factor</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">prev_max</span> <span class="o">-</span> <span class="n">new_max</span><span class="p">)</span>
        <span class="n">new_sum</span> <span class="o">=</span> <span class="n">exp_prev_factor</span> <span class="o">*</span> <span class="n">prev_sum</span> <span class="o">+</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">exp_scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 이전 최댓값이 전역 최댓값 - 다른 최적화
</span>        <span class="n">exp_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">scores</span> <span class="o">-</span> <span class="n">new_max</span><span class="p">)</span>
        <span class="n">new_sum</span> <span class="o">=</span> <span class="n">prev_sum</span> <span class="o">+</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">exp_scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">exp_scores</span><span class="p">,</span> <span class="n">new_max</span><span class="p">,</span> <span class="n">new_sum</span>
</code></pre></div></div> <p><strong>실제 예시 영향:</strong> 길이 2048 시퀀스의 경우, 이 최적화만으로도 비행렬 FLOPs를 전체 연산의 ~15%에서 ~8%로 줄여 ~17% 속도 향상을 제공합니다.</p> <h4 id="최적화-2-시퀀스-길이-병렬화">최적화 2: 시퀀스 길이 병렬화</h4> <p><strong>문제:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># FlashAttention-1: 제한된 병렬화
</span><span class="k">def</span> <span class="nf">flashattention1_parallelization</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">원래 병렬화 전략</span><span class="sh">"""</span>
    <span class="c1"># 배치와 헤드에만 병렬화
</span>    <span class="n">num_thread_blocks</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="o">*</span> <span class="n">num_heads</span>
    
    <span class="c1"># 예시: batch=2, heads=8, seq_len=4096
</span>    <span class="c1"># 결과: 108개의 사용 가능한 프로세서에 대해 16개의 스레드 블록만
</span>    <span class="c1"># GPU 활용도: 16/108 = 15% 😞
</span>    <span class="k">return</span> <span class="n">num_thread_blocks</span>
</code></pre></div></div> <p><strong>해결책:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># FlashAttention-2: 향상된 병렬화
</span><span class="k">def</span> <span class="nf">flashattention2_parallelization</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">시퀀스 차원이 포함된 향상된 병렬화</span><span class="sh">"""</span>
    <span class="c1"># 배치, 헤드, 그리고 시퀀스 블록에 병렬화
</span>    <span class="n">seq_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">seq_len</span> <span class="o">+</span> <span class="n">block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">block_size</span>
    <span class="n">num_thread_blocks</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="o">*</span> <span class="n">num_heads</span> <span class="o">*</span> <span class="n">seq_blocks</span>
    
    <span class="c1"># 같은 예시: batch=2, heads=8, seq_len=4096, block_size=128
</span>    <span class="c1"># seq_blocks = 4096/128 = 32
</span>    <span class="c1"># 결과: 2 * 8 * 32 = 512 스레드 블록
</span>    <span class="c1"># GPU 활용도: 512/108 = 474% (프로세서당 여러 블록) 🚀
</span>    <span class="k">return</span> <span class="n">num_thread_blocks</span>

<span class="k">def</span> <span class="nf">parallel_attention_computation</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">시퀀스 병렬화가 실제로 작동하는 방식</span><span class="sh">"""</span>
    <span class="n">batch_size</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">,</span> <span class="n">head_dim</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">block_size</span> <span class="o">=</span> <span class="mi">128</span>
    
    <span class="c1"># 각 스레드 블록이 다른 시퀀스 세그먼트를 처리
</span>    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">seq_block_idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">block_size</span><span class="p">):</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">seq_block_idx</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">seq_block_idx</span> <span class="o">+</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>
        
        <span class="c1"># 이 블록은 Q[start_idx:end_idx]를 모든 K, V에 대해 처리
</span>        <span class="n">Q_block</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[:,</span> <span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        
        <span class="c1"># 이 Q 블록에 대해 전체 K, V에 대한 어텐션 계산
</span>        <span class="n">block_result</span> <span class="o">=</span> <span class="nf">compute_attention_block</span><span class="p">(</span><span class="n">Q_block</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">)</span>
        <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">block_result</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div> <p><strong>구체적인 예시:</strong></p> <ul> <li> <strong>시나리오</strong>: batch_size=2, 8개 어텐션 헤드, sequence length=4096로 모델 훈련</li> <li> <strong>FlashAttention-1</strong>: 16개 스레드 블록 → 15% GPU 활용도</li> <li> <strong>FlashAttention-2</strong>: 512개 스레드 블록 → 거의 100% GPU 활용도</li> <li> <strong>결과</strong>: 더 나은 하드웨어 활용으로 ~29% 속도 향상</li> </ul> <h4 id="최적화-3-워프-통신-제거">최적화 3: 워프 통신 제거</h4> <p><strong>문제 - “Sliced-K” 접근법:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># FlashAttention-1: 비효율적인 워프 통신
</span><span class="k">def</span> <span class="nf">flashattention1_warp_work</span><span class="p">(</span><span class="n">Q_block</span><span class="p">,</span> <span class="n">K_block</span><span class="p">,</span> <span class="n">V_block</span><span class="p">,</span> <span class="n">num_warps</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">원래 접근법: K와 V를 워프에 분산</span><span class="sh">"""</span>
    <span class="n">head_dim</span> <span class="o">=</span> <span class="n">K_block</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">warp_size</span> <span class="o">=</span> <span class="n">head_dim</span> <span class="o">//</span> <span class="n">num_warps</span>  <span class="c1"># 각 워프가 차원의 1/4 담당
</span>    
    <span class="n">warp_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">warp_id</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_warps</span><span class="p">):</span>
        <span class="n">start_dim</span> <span class="o">=</span> <span class="n">warp_id</span> <span class="o">*</span> <span class="n">warp_size</span>
        <span class="n">end_dim</span> <span class="o">=</span> <span class="p">(</span><span class="n">warp_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">warp_size</span>
        
        <span class="c1"># 각 워프가 K, V의 슬라이스로 계산
</span>        <span class="n">K_warp</span> <span class="o">=</span> <span class="n">K_block</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">start_dim</span><span class="p">:</span><span class="n">end_dim</span><span class="p">]</span>  <span class="c1"># 워프가 슬라이스 담당
</span>        <span class="n">V_warp</span> <span class="o">=</span> <span class="n">V_block</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">start_dim</span><span class="p">:</span><span class="n">end_dim</span><span class="p">]</span>  <span class="c1"># 워프가 슬라이스 담당
</span>        
        <span class="c1"># 부분 결과 계산
</span>        <span class="n">scores_warp</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">Q_block</span><span class="p">,</span> <span class="n">K_warp</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># 모든 Q × K 슬라이스
</span>        <span class="n">attn_warp</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">softmax</span><span class="p">(</span><span class="n">scores_warp</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output_warp</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">attn_warp</span><span class="p">,</span> <span class="n">V_warp</span><span class="p">)</span>
        
        <span class="n">warp_results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">output_warp</span><span class="p">)</span>
    
    <span class="c1"># ❌ 비용이 많이 듦: 모든 워프가 통신하고 동기화해야 함
</span>    <span class="nf">synchronize_warps</span><span class="p">()</span>  <span class="c1"># 비싼 배리어
</span>    <span class="n">final_result</span> <span class="o">=</span> <span class="nf">reduce_across_warps</span><span class="p">(</span><span class="n">warp_results</span><span class="p">)</span>  <span class="c1"># 비싼 리덕션
</span>    
    <span class="k">return</span> <span class="n">final_result</span>
</code></pre></div></div> <p><strong>해결책 - “Sliced-Q” 접근법:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># FlashAttention-2: 효율적인 독립적 워프 작업
</span><span class="k">def</span> <span class="nf">flashattention2_warp_work</span><span class="p">(</span><span class="n">Q_block</span><span class="p">,</span> <span class="n">K_block</span><span class="p">,</span> <span class="n">V_block</span><span class="p">,</span> <span class="n">num_warps</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">새로운 접근법: Q를 워프에 분산</span><span class="sh">"""</span>
    <span class="n">seq_len</span> <span class="o">=</span> <span class="n">Q_block</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">warp_size</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="n">num_warps</span>  <span class="c1"># 각 워프가 시퀀스의 1/4 담당
</span>    
    <span class="n">warp_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">warp_id</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_warps</span><span class="p">):</span>
        <span class="n">start_seq</span> <span class="o">=</span> <span class="n">warp_id</span> <span class="o">*</span> <span class="n">warp_size</span>
        <span class="n">end_seq</span> <span class="o">=</span> <span class="p">(</span><span class="n">warp_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">warp_size</span>
        
        <span class="c1"># 각 워프가 Q의 슬라이스로 계산
</span>        <span class="n">Q_warp</span> <span class="o">=</span> <span class="n">Q_block</span><span class="p">[:,</span> <span class="n">start_seq</span><span class="p">:</span><span class="n">end_seq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>  <span class="c1"># 워프가 Q 슬라이스 담당
</span>        <span class="c1"># K와 V는 공유됨 (읽기 전용) - 통신 불필요!
</span>        
        <span class="c1"># 독립적인 계산 - 동기화 불필요
</span>        <span class="n">scores_warp</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">Q_warp</span><span class="p">,</span> <span class="n">K_block</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># Q 슬라이스 × 모든 K
</span>        <span class="n">attn_warp</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">softmax</span><span class="p">(</span><span class="n">scores_warp</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output_warp</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">attn_warp</span><span class="p">,</span> <span class="n">V_block</span><span class="p">)</span>  <span class="c1"># 어텐션 × 모든 V
</span>        
        <span class="n">warp_results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">output_warp</span><span class="p">)</span>
    
    <span class="c1"># ✅ 동기화 없음: 독립적인 결과들을 단순히 연결
</span>    <span class="n">final_result</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">(</span><span class="n">warp_results</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># 간단한 연결
</span>    
    <span class="k">return</span> <span class="n">final_result</span>
</code></pre></div></div> <p><strong>왜 이것이 작동하는가 - 식당 비유:</strong></p> <ul> <li> <p><strong>FlashAttention-1 (Sliced-K)</strong>: 4명의 요리사가 각각 다른 재료를 담당, 끊임없이 조율해야 함</p> <ul> <li>요리사 1은 야채, 요리사 2는 고기 등을 담당</li> <li>끊임없이 소통해야 함: “야채 준비 끝났나?” “고기 얼마나 준비됐나?”</li> <li>많은 대기와 조율 오버헤드</li> </ul> </li> <li> <p><strong>FlashAttention-2 (Sliced-Q)</strong>: 4명의 요리사가 각각 다른 테이블을 담당, 모든 재료 공유</p> <ul> <li>요리사 1은 테이블 1-10, 요리사 2는 테이블 11-20 등을 담당</li> <li>모든 재료(K, V)가 모든 사람에게 사용 가능</li> <li>조율 불필요 - 각 요리사가 독립적으로 작업</li> </ul> </li> </ul> <p><strong>성능 영향:</strong> 이 최적화는 공유 메모리 동기화 오버헤드를 제거하여 ~28% 속도 향상을 제공합니다.</p> <h3 id="5-실험-결과-성능-향상-증명">5. 실험 결과: 성능 향상 증명</h3> <h4 id="주요-성능-결과">주요 성능 결과</h4> <table> <thead> <tr> <th><strong>지표</strong></th> <th><strong>PyTorch 표준</strong></th> <th><strong>FlashAttention-1</strong></th> <th><strong>FlashAttention-2</strong></th> <th><strong>개선 정도</strong></th> </tr> </thead> <tbody> <tr> <td><strong>속도 (TFLOPs/s)</strong></td> <td>30</td> <td>120</td> <td><strong>230</strong></td> <td><strong>PyTorch 대비 7.7배, FA-1 대비 1.9배</strong></td> </tr> <tr> <td><strong>이론적 최댓값 %</strong></td> <td>10%</td> <td>38%</td> <td><strong>73%</strong></td> <td><strong>GPU 활용도 7.3배 향상</strong></td> </tr> <tr> <td><strong>4K 시퀀스 메모리</strong></td> <td>67 GB</td> <td>3.2 GB</td> <td><strong>3.2 GB</strong></td> <td><strong>21배 메모리 감소</strong></td> </tr> <tr> <td><strong>훈련 비용 (GPT-3)</strong></td> <td>460만 달러</td> <td>230만 달러</td> <td><strong>45만 8천 달러</strong></td> <td><strong>90% 비용 절감</strong></td> </tr> </tbody> </table> <p><strong>이 결과들에 대한 내 분석:</strong></p> <p><strong>정말 인상적인 부분들:</strong></p> <ol> <li> <p><strong>GPU 활용도 점프</strong>: 38%에서 73%로 이론적 최댓값에 도달하는 것은 놀랍습니다. 대부분의 최적화는 10-20% 개선을 제공하지만, 하드웨어 효율성을 거의 두 배로 높이는 것은 뛰어납니다.</p> </li> <li> <p><strong>메모리 효율성 복합 효과</strong>: 21배 메모리 감소는 단순히 RAM을 적게 사용하는 것이 아닙니다 - 완전히 새로운 애플리케이션을 가능하게 합니다. 이제 단일 GPU에서 이전에는 불가능했던 모델을 훈련할 수 있습니다.</p> </li> <li> <p><strong>경제적 변혁</strong>: 90% 비용 절감은 단순한 최적화가 아닙니다 - AI 연구를 민주화하는 패러다임 전환입니다.</p> </li> </ol> <h4 id="절제-연구-각-최적화가-기여하는-바-이해하기">절제 연구: 각 최적화가 기여하는 바 이해하기</h4> <table> <thead> <tr> <th><strong>구성</strong></th> <th><strong>TFLOPs/s</strong></th> <th><strong>개선</strong></th> <th><strong>핵심 이점</strong></th> </tr> </thead> <tbody> <tr> <td><strong>베이스라인 (FlashAttention-1)</strong></td> <td>120</td> <td>-</td> <td>시작점</td> </tr> <tr> <td><strong>+ 비행렬 연산 감소</strong></td> <td>140</td> <td>+17%</td> <td>더 나은 텐서 코어 사용</td> </tr> <tr> <td><strong>+ 시퀀스 병렬화</strong></td> <td>180</td> <td>+29%</td> <td>더 높은 GPU 점유율</td> </tr> <tr> <td><strong>+ 워프 최적화</strong></td> <td><strong>230</strong></td> <td>+28%</td> <td>동기화 제거</td> </tr> <tr> <td><strong>모든 것 결합</strong></td> <td><strong>230</strong></td> <td>+92%</td> <td><strong>곱셈 효과</strong></td> </tr> </tbody> </table> <p><strong>내 심층 분석:</strong></p> <p><strong>각 최적화가 중요한 이유:</strong></p> <ol> <li> <p><strong>비행렬 연산 감소 (+17%)</strong>:</p> <ul> <li>작아 보이지만 실제로는 기초적임</li> <li>현대 GPU는 행렬 곱셈을 중심으로 설계됨 - 나머지는 부차적</li> <li>비싼 연산을 ~50% 줄임으로써 GPU의 진정한 잠재력을 해방</li> <li>비포장도로에서 고속도로로 바꾸는 것과 같음 - 기본 경로가 이제 최적화됨</li> </ul> </li> <li> <p><strong>시퀀스 병렬화 (+29%)</strong>:</p> <ul> <li>리소스 활용에 관한 것 - 고전적인 시스템 최적화</li> <li>이전: GPU 코어의 85%가 긴 시퀀스에 대해 유휴 상태</li> <li>이후: 거의 100% 활용</li> <li>통찰: 어텐션이 본질적으로 순차적으로 보여도 일부분을 병렬화할 수 없다는 뜻은 아님</li> </ul> </li> <li> <p><strong>워프 최적화 (+28%)</strong>:</p> <ul> <li>가장 미묘하지만 아마도 가장 중요한 최적화</li> <li>깊은 하드웨어 아키텍처를 이해하는 것</li> <li>통찰: 공유 메모리 통신은 숨겨진 병목</li> <li>동기화를 제거함으로써 근본적인 제약을 없앰</li> </ul> </li> </ol> <p><strong>곱셈 효과:</strong> 17% + 29% + 28% = 74%이지만 실제 개선은 92%입니다. 이런 초선형 개선이 일어나는 이유:</p> <ul> <li>각 최적화가 다른 것들이 더 잘 작동하게 만듦</li> <li>하나의 병목을 제거하면 종종 다른 병목들도 드러나고 제거됨</li> <li>하드웨어 최적화는 단순히 더하는 것이 아니라 복합됨</li> </ul> <h4 id="순방향-vs-역방향-패스-분석">순방향 vs 역방향 패스 분석</h4> <table> <thead> <tr> <th><strong>패스</strong></th> <th><strong>방법</strong></th> <th><strong>TFLOPs/s</strong></th> <th><strong>이론적 %</strong></th> <th><strong>내 분석</strong></th> </tr> </thead> <tbody> <tr> <td><strong>순방향</strong></td> <td>PyTorch</td> <td>60</td> <td>19%</td> <td>메모리 제한적, 비효율적</td> </tr> <tr> <td><strong>순방향</strong></td> <td>FlashAttention-2</td> <td><strong>187</strong></td> <td><strong>60%</strong></td> <td><strong>3.1배 개선</strong></td> </tr> <tr> <td><strong>역방향</strong></td> <td>PyTorch</td> <td>45</td> <td>14%</td> <td>더욱 도전적</td> </tr> <tr> <td><strong>역방향</strong></td> <td>FlashAttention-2</td> <td><strong>165</strong></td> <td><strong>53%</strong></td> <td><strong>3.7배 개선</strong></td> </tr> </tbody> </table> <p><strong>역방향 패스 개선이 더 극적인 이유:</strong></p> <p>역방향 패스가 더 복잡한 이유:</p> <ol> <li> <strong>더 많은 행렬 연산</strong>: 순방향 패스의 2개 vs 5개 행렬 곱셈</li> <li> <strong>더 많은 메모리 압박</strong>: 중간값을 저장/재계산해야 함</li> <li> <strong>복잡한 의존성</strong>: 기울기 계산에 더 복잡한 데이터 의존성</li> </ol> <p>FlashAttention-2의 최적화가 역방향 패스에서 더 도움이 되는 이유:</p> <ul> <li> <strong>메모리 효율성</strong>: 메모리가 부족할 때 타일링과 재계산 전략이 빛남</li> <li> <strong>병렬화</strong>: 더 많은 계산은 더 많은 병렬 실행 기회를 의미</li> <li> <strong>통신 감소</strong>: 복잡한 의존성으로 인해 통신 제거가 더 가치 있음</li> </ul> <h3 id="6-실제-영향과-중요성">6. 실제 영향과 중요성</h3> <h4 id="훈련-시간-혁명">훈련 시간 혁명</h4> <p><strong>GPT-3 175B 훈련 비교:</strong></p> <table> <thead> <tr> <th><strong>방법</strong></th> <th><strong>시간</strong></th> <th><strong>비용</strong></th> <th><strong>접근성</strong></th> </tr> </thead> <tbody> <tr> <td><strong>표준</strong></td> <td>~200일</td> <td>460만 달러</td> <td>거대 기술 기업만</td> </tr> <tr> <td><strong>FlashAttention-1</strong></td> <td>~100일</td> <td>230만 달러</td> <td>대기업</td> </tr> <tr> <td><strong>FlashAttention-2</strong></td> <td><strong>10일</strong></td> <td><strong>45만 8천 달러</strong></td> <td><strong>많은 연구소</strong></td> </tr> </tbody> </table> <p><strong>더 넓은 함의에 대한 내 평가:</strong></p> <p><strong>연구 민주화:</strong></p> <ul> <li>이전: Google, OpenAI, Microsoft만이 대형 모델 훈련 가능</li> <li>이후: 중견 기업과 자금이 충분한 연구소들이 참여 가능</li> <li>참여자 풀을 확장하여 AI 연구를 10배 가속화</li> </ul> <p><strong>개발 사이클 가속화:</strong></p> <ul> <li>200일 훈련 사이클 vs 10일 사이클로 빠른 반복 가능</li> <li>연구자들이 같은 시간에 20배 더 많은 실험 시도 가능</li> <li>복합 효과: 더 빠른 실험 → 더 나은 통찰 → 더 나은 모델</li> </ul> <p><strong>환경 영향:</strong></p> <ul> <li>90% 비용 절감은 종종 ~90% 에너지 절감으로 이어짐</li> <li>FlashAttention-2로 GPT-3 훈련은 ~10배 적은 전력 사용</li> <li>대규모 AI 연구를 더 지속 가능하게 만듦</li> </ul> <h3 id="7-비판적-평가와-제한사항">7. 비판적 평가와 제한사항</h3> <p><strong>FlashAttention-2를 성공적으로 만드는 요소들:</strong></p> <ol> <li> <strong>하드웨어-소프트웨어 공동 설계</strong>: GPU 아키텍처에 대한 깊은 이해</li> <li> <strong>체계적 최적화</strong>: 하나의 큰 변화보다는 세 가지 상호보완적 개선</li> <li> <strong>실용적 영향</strong>: 많은 연구자들이 직면하는 실제 문제 해결</li> <li> <strong>엄격한 평가</strong>: 여러 차원에 걸친 포괄적 벤치마크</li> </ol> <p><strong>제한사항과 제약사항:</strong></p> <ol> <li> <p><strong>하드웨어 의존성</strong>: 현대 GPU(A100, H100)에서만 작동</p> <ul> <li> <strong>내 견해</strong>: 이는 장점이자 단점 - 고성능을 위해서는 특화가 필요</li> </ul> </li> <li> <p><strong>복잡성</strong>: 표준 어텐션보다 훨씬 복잡</p> <ul> <li> <strong>내 견해</strong>: 복잡성은 성능 향상으로 정당화되지만 유지보수 우려 제기</li> </ul> </li> <li> <p><strong>정밀도 요구사항</strong>: fp16/bf16 필요, fp32로는 효율적으로 작동하지 않음</p> <ul> <li> <strong>내 견해</strong>: 수치 정밀도를 제한하지만 텐서 코어 활용을 위해 필요</li> </ul> </li> <li> <p><strong>블록 크기 민감성</strong>: 성능이 좋은 블록 크기 선택에 의존</p> <ul> <li> <strong>내 견해</strong>: 일부 튜닝 전문성이 필요하지만 기본값이 잘 작동</li> </ul> </li> </ol> <h3 id="8-왜-이-논문이-ai-진보에-중요한가">8. 왜 이 논문이 AI 진보에 중요한가</h3> <p><strong>기술적 우수성:</strong> FlashAttention-2는 최고의 시스템 연구를 대표합니다 - 깊은 하드웨어 이해와 알고리즘 혁신을 결합하여 실용적 문제를 해결합니다.</p> <p><strong>더 넓은 영향:</strong> 이 작업은 인프라 개선이 알고리즘 돌파구만큼 중요할 수 있음을 보여줍니다. 때로는 더 나은 AI로 가는 길이 새로운 모델 아키텍처가 아니라 기존 아키텍처를 훨씬 더 효율적으로 실행하게 만드는 것입니다.</p> <p><strong>연구 철학:</strong> 이 논문은 다음의 가치를 보여줍니다:</p> <ul> <li>최적화하기 전에 병목 현상을 프로파일링하고 이해하기</li> <li>임시방편적 개선보다는 체계적 최적화</li> <li>여러 차원에 걸친 엄격한 벤치마킹</li> <li>계산적 영향과 경제적 영향 모두 고려</li> </ul> <p><strong>개인적 성찰:</strong> FlashAttention-2에서 가장 인상적인 것은 이론적 돌파구가 아닌 엔지니어링 우수성을 통해 불가능한 것을 가능하게 만든다는 점입니다. AI에서 인프라 작업이 알고리즘 혁신만큼 변혁적일 수 있다는 것을 상기시켜줍니다. 대형 모델 훈련의 90% 비용 절감은 단순한 숫자가 아닙니다 - 전체 분야의 진보를 가속화할 AI 연구의 민주화입니다.</p> <p>이 논문은 또한 하드웨어를 깊이 이해하는 것의 중요성을 보여줍니다. 저자들은 단순히 코드를 프로파일링한 것이 아니라 하드웨어 제약에 맞게 알고리즘을 재설계할 만큼 GPU 아키텍처를 충분히 이해했습니다. AI 워크로드가 증가하고 에너지 효율성이 중요해지면서 이는 점점 더 중요해지고 있습니다.</p> <p>내 의견으로는, FlashAttention-2는 오늘날 우리가 보고 있는 긴 컨텍스트 AI 혁명의 핵심 촉진자 중 하나로 기억될 것입니다. 100K+ 컨텍스트 윈도우를 가진 모델들이 실용적이 된 것은 주로 기본 계산을 실현 가능하게 만든 이와 같은 작업 때문입니다.</p> <hr> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/fa3/">Flash Attention 3</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/fa/">Flash Attention</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/usp/">Unified Sequence Parallelism</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/sp/">Reducing Activation Recomputation in Large Transformer Models</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/deepspeed_ulysses/">DeepSpeed Ulysses</a> </li> <div id="disqus_thread" style="max-width: 930px; margin: 0 auto;"> <script type="text/javascript">
    var disqus_shortname  = 'sungyubkim';
    var disqus_identifier = '/blog/fa2';
    var disqus_title      = "Flash Attention 2";
    (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by Disqus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2026 Sung-Yub Kim. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: January 29, 2026. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?v=c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?v=c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?v=f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?v=ccc841c459bfc0e64c1c2b5acd10df02"></script> </body> </html>