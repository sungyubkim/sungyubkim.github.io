---
title: "Pipeline Parallel (GPipe)"
date: 2025-05-29
last_modified_at: 2026-02-03
layout: post
permalink: /blog/pp/
description: "GPipe의 마이크로 배치 파이프라인 병렬화를 통한 거대 신경망 학습과 동기식 gradient 업데이트의 학습 일관성 보장."
tags: pipeline-parallelism distributed-training memory-efficiency
thumbnail: assets/img/blog/pp.png
series: distributed-training
series_order: 2
series_title: "Distributed Training Series"
related_posts: true
disqus_comments: false
giscus_comments: true
toc:
  sidebar: left
---

# TL;DR

> GPipe는 모델의 순차적 레이어를 여러 가속기에 분할하고 마이크로 배치를 파이프라인으로 통과시키며 동기식 gradient 업데이트를 수행하여 거대한 신경망 학습을 가능하게 하는 파이프라인 병렬화 라이브러리입니다.
> 핵심 혁신은 배치 분할 알고리즘과 activation 재계산을 결합하여 파티션 수와 무관하게 학습 일관성을 유지하면서 거의 선형적인 속도 향상을 달성하는 것입니다.
> 저자들은 557M 파라미터 AmoebaNet을 ImageNet에서 84.4% top-1 정확도로 확장하고, 6B 파라미터 Transformer를 100개 이상의 언어에서 bilingual 베이스라인을 능가하도록 학습시켜 그 유연성을 입증했습니다.
> 중요한 제약사항은 각 개별 레이어가 단일 가속기의 메모리에 들어가야 하며, 네트워크가 순차적 레이어 스택으로 표현 가능해야 한다는 점입니다.

- Paper Link: [https://arxiv.org/pdf/1811.06965](https://arxiv.org/pdf/1811.06965)

---

# Related Papers

- [Megatron-LM](/blog/tp/) - 텐서 모델 병렬화를 통한 대규모 Transformer 학습
- [How to Scale Your Model: Transformers](https://jax-ml.github.io/scaling-book/transformers/) - TPU 성능과 Transformer 스케일링 가이드
- [TorchTitan](https://arxiv.org/abs/2410.06511) - PyTorch 네이티브 LLM 사전 학습 솔루션
- [Unlocking Agentic RL Training for GPT-OSS](https://huggingface.co/blog/LinkedIn/gpt-oss-agentic-rl) - 대규모 RL 학습 실전 회고
- [FP8-LM](https://arxiv.org/abs/2310.18313) - FP8을 활용한 대규모 언어 모델 학습

---

# Takeaways

## 1. Contribution

GPipe의 핵심 동기는 딥러닝의 근본적인 긴장 관계에서 비롯됩니다. 더 큰 모델은 다양한 작업에서 일관되게 더 나은 품질을 제공하지만, 단일 가속기의 메모리를 초과하는 모델 용량으로 확장하려면 역사적으로 작업별 및 아키텍처별 엔지니어링이 필요했습니다. GPipe 이전에, 단일 디바이스 메모리 제한을 초과하는 모델을 학습하려는 실무자들은 바람직하지 않은 여러 절충안에 직면했습니다. 네트워크의 순차적 파티션을 서로 다른 디바이스에 배치하는 naive 모델 병렬화는 특정 시점에 하나의 디바이스만 계산하고 나머지는 유휴 상태로 있기 때문에 치명적으로 낮은 하드웨어 활용률을 초래합니다. Mesh-TensorFlow(SPMD)와 같은 대안적 접근법은 개별 텐서 연산을 디바이스에 분산시키지만, 이는 고대역폭 인터커넥트를 요구하며 효율적으로 병렬화할 수 있는 연산 유형을 제한하여 채널 차원이 완전히 연결된 convolutional 네트워크와 같은 아키텍처에는 부적합합니다. PipeDream은 파이프라인 병렬화를 시도했지만 weight staleness를 생성하는 비동기 weight 업데이트를 도입하여 각 디바이스에 여러 버전의 모델 파라미터 복사본을 요구하므로 진정으로 큰 모델로 확장할 수 있는 능력을 제한했습니다.

GPipe는 세 가지 핵심 아이디어를 응집력 있는 시스템으로 결합하여 파이프라인 병렬화에 대한 근본적으로 새로운 접근법을 도입함으로써 이 격차를 해결합니다. 첫째, 학습 미니 배치를 $M$개의 더 작은 마이크로 배치로 나누고 이를 $K$개의 디바이스 파티션을 통해 파이프라인으로 전달하는 마이크로 배치 분할 알고리즘을 제안합니다. 이것이 여러 디바이스를 동시에 활성화하여 naive 모델 병렬화를 괴롭히는 유휴 "버블" 시간을 대폭 줄이는 핵심 메커니즘입니다. 둘째, 파라미터 업데이트를 적용하기 전에 모든 마이크로 배치에 걸쳐 gradient를 누적하여 동기식 미니 배치 gradient descent를 유지함으로써, 얼마나 많은 파티션이 사용되든 학습 동역학이 수학적으로 동일함을 보장합니다. 이는 연구자들이 수렴 동작의 변화를 걱정하지 않고 더 많은 디바이스로 확장할 수 있다는 점에서 중요한 속성입니다. 셋째, activation 재계산(gradient checkpointing)을 통합하여 forward pass 동안 중간 activation을 버리고 backward pass 동안 재계산함으로써 추가 계산을 극적으로 감소된 메모리 소비와 교환합니다.

GPipe의 기여가 갖는 실용적 의미는 상당합니다. 이미지 분류에서 저자들은 AmoebaNet을 5억 5700만 개의 파라미터로 확장하여 ImageNet-2012에서 84.4% top-1 정확도를 달성했으며, 이는 공개 데이터만 사용하여 이전 state-of-the-art인 83.9%를 능가합니다. 이 모델은 CIFAR-10 오류를 1.0%로, CIFAR-100 오류를 8.7%로 줄이는 등 6개의 추가 데이터셋에서 경쟁력 있거나 state-of-the-art 전이 학습 결과를 달성합니다. 기계 번역에서 GPipe는 102개 언어 쌍에서 동시에 60억 파라미터, 128-layer Transformer를 학습할 수 있게 하며, 결과 모델은 모든 100개 언어 쌍에서 개별적으로 학습된 bilingual Transformer Big 베이스라인을 능가합니다. 이는 단일 다국어 모델이 충분히 확장될 경우 이러한 다양한 언어 세트에서 전용 bilingual 모델의 품질과 일치하거나 초과할 수 있음을 보여주는 첫 번째 시연입니다. 확장성 수치도 인상적입니다. GPipe는 128개의 TPUv3 가속기에서 최대 839억 개의 파라미터를 가진 모델을 학습할 수 있게 하며, 이는 단일 가속기가 처리할 수 있는 것보다 298배 증가한 것입니다.

GPipe의 기여를 특히 시의적절하게 만드는 것은 범용, 아키텍처 불가지론적 솔루션을 제공한다는 점입니다. Mesh-TensorFlow의 SPMD 접근법과 달리 GPipe는 convolutional 및 Transformer 아키텍처를 포함하여 순차적 레이어로 표현 가능한 모든 네트워크에서 작동합니다. PipeDream과 달리 weight 버전 관리가 필요하지 않으며 일관된 학습을 보장합니다. 라이브러리는 최소한의 사용자 개입만 필요합니다. 사용자는 파티션 수 $K$, 마이크로 배치 수 $M$, 레이어 정의만 지정하면 됩니다. 이러한 인터페이스의 단순성과 접근법의 일반성은 GPipe를 특정 아키텍처를 위한 특수 알고리즘이 아니라 극도로 큰 모델의 학습을 민주화하는 인프라로 자리매김합니다.

## 2. Methodology

### 2.1 Core Intuition

GPipe의 근본적인 통찰력은 모델 병렬 딥러닝 맥락에 적용된 고전적인 CPU 파이프라이닝에서 차용되었습니다. Naive 모델 병렬화에서는 네트워크가 $K$개의 디바이스에 분할되지만 레이어 간 순차적 종속성 때문에 forward pass 동안 및 backward pass 동안 한 번에 하나의 디바이스만 활성화됩니다. 즉, 하드웨어 활용률이 약 $\frac{1}{K}$이며, 이는 효율성에 치명적입니다. 핵심 관찰은 단일 입력 예제에 대해서는 레이어 간에 순차적 종속성이 있지만 서로 다른 입력 예제 간에는 그러한 종속성이 없다는 것입니다. 미니 배치를 여러 마이크로 배치로 분할하면 첫 번째 디바이스가 두 번째 디바이스가 첫 번째 마이크로 배치를 처리하는 동안에도 첫 번째 마이크로 배치를 마치는 즉시 두 번째 마이크로 배치 처리를 시작할 수 있습니다. 이는 정상 상태에서 모든 디바이스가 동시에 활성화되는 파이프라인을 생성합니다.

이론적 기반은 두 가지 속성에 있습니다. 첫째, 합의 gradient는 gradient의 합과 같습니다. 미니 배치에 대한 손실이 개별 예제에 대한 손실의 합(또는 평균)이므로, 마이크로 배치에 걸쳐 gradient를 누적하고 한 번에 적용하는 것은 전체 미니 배치에 대해 한 번에 gradient를 계산하는 것과 수학적으로 동등합니다. 즉, GPipe의 파이프라이닝은 최적화 경로를 어떤 식으로든 변경하지 않으며, PipeDream과 같은 비동기 접근법이 제공할 수 없는 학습 일관성 보장을 제공합니다. 둘째, 딥 네트워크 학습의 메모리 병목은 모델 파라미터보다 중간 activation에 의해 지배됩니다. $L$개의 레이어와 배치 크기 $N$을 가진 네트워크의 경우 activation 메모리는 $O(N \times L)$로 스케일됩니다. 마이크로 배치 분할과 재계산(경계 activation만 저장하고 역전파 중에 중간 activation을 재계산)을 결합하여 GPipe는 피크 activation 메모리를 $O(N + \frac{L}{K} \times \frac{N}{M})$로 줄이며, 이는 $M$과 $K$가 클 때 극적으로 작아집니다.

효율성 분석은 파이프라인 버블, 즉 파이프라인의 fill 및 drain 단계 동안 일부 디바이스가 유휴 상태인 시간의 분수 오버헤드가 $O(\frac{K-1}{M+K-1})$임을 보여줍니다. $M \gg K$일 때 이 오버헤드는 무시할 수 있게 됩니다. 실험적으로 저자들은 $M \geq 4K$가 버블 오버헤드를 실질적으로 무의미하게 만들기에 충분하다는 것을 발견했습니다. 이는 유리한 스케일링 영역을 설정합니다. 더 많은 디바이스($K$ 증가)를 추가함에 따라 효율성을 유지하기 위해 $M$을 비례적으로 증가시킬 수 있으면서도 효과적인 모델 용량을 증가시킬 수 있습니다.

### 2.2 Model Architecture

GPipe는 특정 모델 아키텍처가 아니라 기존 아키텍처를 감싸는 병렬화 라이브러리입니다. 시스템은 모든 딥 신경망이 $L$개의 레이어 시퀀스로 표현될 수 있다는 추상화에서 작동하며, 각 레이어 $L_i$는 forward 계산 함수 $f_i$와 파라미터 $w_i$로 구성됩니다. $K$개의 파티션이 주어지면 GPipe는 연속된 레이어를 $K$개의 셀로 그룹화합니다. 레이어 $i$부터 $j$까지를 포함하는 각 셀 $p_k$는 복합 forward 함수 $F_k = f_j \circ \ldots \circ f_{i+1} \circ f_i$와 자동 미분을 통해 파생된 해당 역전파 함수 $B_k$를 갖습니다.

전체 파이프라인은 다음과 같이 작동합니다:

```
입력: 크기 N의 미니 배치, K개 파티션, M개 마이크로 배치
─────────────────────────────────────────────────────────
1. L개 레이어를 K개 셀로 파티션: p_0, p_1, ..., p_{K-1}
2. 셀 p_k를 가속기 k에 배치
3. 미니 배치를 크기 N/M의 M개 마이크로 배치로 분할
4. FORWARD: 마이크로 배치를 셀을 통해 파이프라인
   - m = 0..M-1에 대해: 마이크로 배치 m을 셀 0..K-1을 통해 스트림
   - 경계 activation만 저장 (재계산)
5. BACKWARD: gradient를 역순으로 파이프라인
   - 각 셀 내에서 forward activation 재계산
   - 모든 M개 마이크로 배치에 걸쳐 gradient 누적
6. UPDATE: 누적된 gradient를 동기적으로 적용
```

파티셔닝 알고리즘은 셀 전체에 걸쳐 추정된 계산 비용의 분산을 최소화하여 레이어를 셀에 할당합니다. 각 레이어는 선택적으로 비용 추정 함수 $c_i$를 제공할 수 있으며, 셀의 비용은 $C_k = \sum_{l=i}^{j} c_l$입니다. 비용을 균형 잡음으로써 시스템은 모든 디바이스가 각자의 계산을 거의 동시에 완료하여 파이프라인 처리량을 최대화하도록 보장합니다. 통신 프리미티브는 인접 디바이스 간에 activation 텐서를 전송하기 위해 파티션 경계에 자동으로 삽입됩니다.

### 2.3 Key Algorithms & Mechanisms

**마이크로 배치 파이프라인 병렬화.** GPipe의 핵심 알고리즘은 마이크로 배치 파이프라이닝 방식입니다. Forward pass 동안 크기 $N$의 미니 배치는 각각 크기 $\frac{N}{M}$인 $M$개의 동일한 마이크로 배치로 나뉩니다. $F_{k,m}$을 마이크로 배치 $m$에 대한 셀 $k$의 forward 계산이라고 합시다. 파이프라인 스케줄은 다음과 같이 진행됩니다: 시간 단계 $t$에서 셀 $k$는 마이크로 배치 $m = t - k$ ($0 \leq m < M$일 때)를 처리합니다. 즉, $K-1$ 단계의 초기 fill 단계 후 모든 $K$개의 디바이스가 동시에 활성화되며, 각각 네트워크의 다른 단계에서 다른 마이크로 배치를 처리합니다. Forward pass는 $M + K - 1$ 시간 단계 후에 완료됩니다. Backward pass는 역순으로 유사한 파이프라인 스케줄을 따르며, $B_{k,m}$은 마이크로 배치 $m$에 대한 셀 $k$의 backward 계산을 나타냅니다.

중요한 속성은 단일 미니 배치 내의 모든 마이크로 배치가 forward pass에 대해 동일한 모델 파라미터를 사용한다는 것입니다. 이는 모든 $M$개의 마이크로 배치가 처리된 후에만 파라미터가 업데이트되기 때문에 가능합니다. Gradient 누적은 간단합니다. $g_{k,m}$이 셀 $k$의 파라미터에 대한 마이크로 배치 $m$의 gradient 기여도를 나타낼 때, 전체 gradient는 다음과 같습니다:

$$\nabla_{w_k} \mathcal{L} = \frac{1}{M} \sum_{m=0}^{M-1} g_{k,m}$$

이는 미니 배치 끝에서 모든 셀에 걸쳐 동기적으로 적용됩니다. 이것이 전체 미니 배치에 대한 gradient 계산과 수학적으로 동일하기 때문에 학습 동역학은 파티션 수 $K$와 마이크로 배치 수 $M$에 완전히 불변입니다. 이는 weight staleness가 근사 오류를 도입하는 PipeDream이 제공하는 것보다 강력한 보장입니다.

**Activation 재계산 (Gradient Checkpointing).** 표준 역전파 동안 레이어 $i$에서 gradient를 계산하려면 레이어 $i+1$의 gradient(upstream gradient)와 forward pass에서 레이어 $i$의 캐시된 activation이 모두 필요합니다. 즉, 모든 중간 activation이 저장되어야 하며, 이는 $O(N \times L)$ 메모리 소비로 이어집니다. GPipe는 각 셀 내에서 재계산을 적용합니다. Forward pass 동안 셀 경계의 출력 activation만 저장됩니다. Backward pass가 셀 $k$에 도달하면 복합 forward 함수 $F_k$가 저장된 경계 activation에서 재계산되어 해당 셀 내의 모든 중간 activation을 재생성합니다. 이는 메모리의 극적인 감소를 위해 계산의 약 2배를 교환합니다.

재계산을 사용하면 가속기당 피크 activation 메모리는 $O(\frac{N}{M} \times \frac{L}{K} + \frac{N}{M})$가 됩니다. 첫 번째 항은 셀 내 하나의 마이크로 배치에 대한 backward pass 동안 재계산하고 일시적으로 저장해야 하는 activation을 나타내며, 두 번째 항은 모든 마이크로 배치에 걸친 경계 activation을 나타냅니다. 전체 미니 배치 경계 activation을 고려하면 총합은 $O(N + \frac{L}{K} \times \frac{N}{M})$입니다. 핵심 통찰력은 $M$(더 많은 마이크로 배치)을 증가시키고 $K$(더 많은 파티션)를 증가시키는 것 모두가 피크 메모리를 줄여 훨씬 더 큰 모델로 확장할 수 있게 한다는 것입니다.

**버블 오버헤드 분석.** 파이프라인 버블은 fill 단계(모든 디바이스가 활성화되지 않은 첫 $K-1$ 시간 단계)와 drain 단계(마지막 $K-1$ 시간 단계) 동안 발생합니다. 총 활성 계산 시간은 $2MK$ 단위(forward와 backward가 마이크로 배치당 셀당 동일한 시간이 걸린다고 가정)이며, 총 경과 시간은 $2(M + K - 1)K$ 단위입니다. 버블에서 낭비되는 시간의 비율은 다음과 같습니다:

$$\text{Bubble Fraction} = \frac{K - 1}{M + K - 1}$$

$M = 4K$의 경우 이는 $\frac{K-1}{5K-1} \approx 20\%$를 제공하며, $K = 4$에 대해 $M = 32$의 경우 $\frac{3}{35} \approx 8.6\%$로 떨어집니다. 저자들은 backward pass 동안의 재계산이 버블 시간과 부분적으로 겹치도록 스케줄될 수 있어 효과적인 영향을 더욱 줄일 수 있다고 언급합니다. 이는 셀이 마이크로 배치에 대한 upstream gradient를 받으면 모든 upstream gradient를 기다리지 않고 즉시 forward activation 재계산을 시작할 수 있기 때문입니다.

**Batch Normalization 처리.** Batch normalization이 있는 경우, 충분 통계량(평균 및 분산)은 전체 미니 배치가 아닌 각 마이크로 배치에 대해 학습 중에 계산됩니다. 이는 전체 미니 배치에 대한 통계를 계산하려면 파이프라이닝 추상화를 깨는 cross-micro-batch 통신이 필요하기 때문에 실용적인 선택입니다. 그러나 평가를 위해 GPipe는 전체 미니 배치에 대해 계산된 충분 통계량의 이동 평균을 추적하여 추론 동작이 마이크로 배치 분할에 영향을 받지 않도록 합니다.

**파티셔닝 알고리즘.** 자동 파티셔닝 알고리즘은 셀 간 계산 비용 $C_k$의 분산이 최소화되도록 연속 레이어를 셀에 할당합니다. 이는 $O(L \times K)$ 시간에 동적 프로그래밍으로 최적으로 해결할 수 있는 1차원 파티셔닝 문제입니다. 각 레이어의 비용 추정기는 FLOP, 프로파일링된 실행 시간 또는 사용자 제공 추정치에서 파생될 수 있습니다. 균형 잡힌 파티셔닝은 파이프라인 처리량이 가장 느린 셀에 의해 제한되기 때문에 중요합니다.

**통신 패턴.** GPipe의 통신 패턴은 최소화됩니다. 각 시간 단계에서 각 파티션 경계는 두 인접 디바이스 간에 단일 activation 텐서(forward 동안) 또는 gradient 텐서(backward 동안)를 전송합니다. 이는 all-reduce 또는 broadcast가 아닌 point-to-point 전송이므로 대역폭 효율적입니다. 논문은 고속 NVLink 없이 PCI-E를 통해 연결된 GPU에서도 통신 오버헤드가 무시할 수 있으며, 전용 인터커넥트가 있는 TPU와 유사한 속도 향상 비율을 달성함을 보여줍니다.

### 2.4 Implementation Details

GPipe는 Google의 Lingvo 프레임워크 내에서 구현되었지만 설계 원칙은 프레임워크 불가지론적입니다. 사용자 인터페이스는 세 가지 사양만 필요합니다: 파티션 수 $K$, 마이크로 배치 수 $M$, 순차 레이어 정의. 라이브러리는 자동 파티셔닝, 통신 삽입, 재계산 및 gradient 누적을 처리합니다.

이미지 분류 실험의 경우, 저자들은 $480 \times 480$ 입력 이미지에서 557M 파라미터를 가진 AmoebaNet-B(18, 512)를 사용하며, 4개의 TPUv2 가속기에 파티션됩니다. 학습은 RMSProp optimizer를 사용합니다(각 파라미터는 파라미터, gradient 및 optimizer 상태에 대해 12바이트의 저장 공간이 필요). 데이터 증강에는 수평 플리핑 및 cutout이 포함됩니다.

다국어 NMT 실험의 경우, Transformer 아키텍처는 1024의 고정 모델 차원을 사용하며, 깊이(레이어 수 $L$)와 너비(feed-forward 은닉 차원 $H$ 및 attention 헤드 수 $A$)를 따라 스케일링합니다. 가장 큰 모델인 60억 파라미터를 가진 $T(64, 16384, 32)$는 16개 가속기에 파티션됩니다. 어휘 크기는 64K이며 시퀀스 길이는 1024입니다. 학습은 언어 균형을 위해 온도 기반 샘플링을 사용합니다. 깊은 Transformer를 위해 두 가지 중요한 안정성 기법이 사용됩니다: (1) 레이어 수에 따라 feed-forward 레이어의 초기화를 축소(Fixup 초기화 원칙 준수), (2) 크기가 임계값을 초과할 때 logit 사전 활성화 클리핑. 배치 크기는 4M 토큰까지 확장되며, 이는 당시 NMT에 사용된 가장 큰 배치 크기로 보고되었습니다.

디바이스당 메모리 복잡도는 $O(\frac{P}{K} + N + \frac{L}{K} \times \frac{N}{M})$이며, 여기서 $\frac{P}{K}$는 파티션의 파라미터 메모리, $N$은 경계 activation을 설명하고, $\frac{L}{K} \times \frac{N}{M}$은 피크 재계산된 activation 메모리입니다. 계산 오버헤드는 재계산으로 인해 기본 계산 비용의 약 $\frac{1}{3}$입니다(forward pass는 전체 forward+backward 계산의 약 3분의 1). 버블 오버헤드는 전체 시간에 $\frac{M+K-1}{M}$의 추가 곱셈 인수를 더합니다.

## 3. Results

GPipe의 실험적 평가는 확장성(모델이 얼마나 커질 수 있는가), 효율성(처리량이 얼마나 잘 확장되는가), 다운스트림 작업 품질(더 큰 모델이 실제로 더 나은 성능을 내는가)의 세 가지 차원에 걸쳐 있습니다. 세 가지 모두에서 결과는 설득력 있고 잘 뒷받침됩니다.

**확장성.** 논문의 표 1은 서로 다른 구성에서 달성 가능한 최대 모델 크기를 보여줍니다. 각각 8GB 메모리를 가진 NVIDIA GPU에서 GPipe는 AmoebaNet을 82M 파라미터(단일 디바이스, GPipe 없음)에서 18억 파라미터(8 파티션)로 확장하며, 이는 22배 증가입니다. AmoebaNet의 경우 레이어 간 파라미터 분포가 불균형하여 스케일링이 준선형입니다. 각각 16GB를 가진 TPUv3의 Transformer의 경우, 스케일링은 거의 완벽하게 선형입니다: 282M(단일 디바이스)에서 839억 파라미터(128 파티션)로, 298배 증가입니다. Transformer에 대한 이러한 선형 스케일링은 각 Transformer 레이어가 동일한 파라미터 수와 계산 비용을 가져 파티셔닝이 완벽하게 균형 잡히기 때문에 발생합니다.

| 구성 | AmoebaNet 파라미터 (GPU) | Transformer 파라미터 (TPU) |
|---|---|---|
| Naive-1 (GPipe 없음) | 82M | 282M |
| Pipeline-1 (재계산만) | 318M (3.9배) | 786M (2.8배) |
| Pipeline-8 | 18억 (22배) | 53억 (19배) |
| Pipeline-128 | N/A | 839억 (298배) |

재계산만으로도(Pipeline-1) 다중 디바이스 병렬화가 적용되기 전에도 계산을 메모리와 교환하여 2.8-3.9배의 메모리 감소를 제공합니다. 이는 재계산과 파이프라인 병렬화라는 두 메커니즘이 상호 보완적임을 보여줍니다.

**효율성.** 표 2는 서로 다른 $K$와 $M$ 값에 걸친 정규화된 학습 처리량을 보여줍니다. 핵심 발견은 $M \geq 4K$일 때 버블 오버헤드가 무시할 수 있게 되고 처리량이 디바이스 수에 거의 선형으로 스케일링된다는 것입니다. $K=8$ 및 $M=32$인 Transformer의 경우, 처리량은 $K=2, M=1$ 대비 6.3배이며, 이는 4배 디바이스 증가에 대한 이론적 최대값인 4배에 근접합니다. AmoebaNet 결과는 부하 불균형으로 인해 준선형 스케일링($K=8, M=32$로 $K=2$ 대비 정규화 시 3.48배)을 보여줍니다. $M=1$일 때 효과적으로 파이프라이닝이 없으며 처리량은 디바이스 수에 관계없이 평평하게 유지되어 예상되는 동작을 확인합니다.

**통신 오버헤드.** 표 3은 GPipe가 NVLink 없이 PCI-E를 통해 연결된 GPU에서도 유사한 스케일링을 달성하며, 2개에서 8개 파티션으로 이동할 때 AmoebaNet 및 Transformer에 대해 각각 2.7배 및 3.3배 속도 향상을 달성함을 보여줍니다. 이는 GPipe가 특수 인터커넥트 없이 상용 하드웨어 설정에 적용 가능함을 의미하므로 중요한 실용적 결과입니다.

**이미지 분류.** 557M 파라미터 AmoebaNet-B(18, 512)는 ImageNet-2012에서 84.4% top-1 및 97% top-5 정확도를 달성하여 공개 데이터로 학습된 모델에 대한 새로운 state-of-the-art를 설정합니다. 이 모델에서 6개의 더 작은 데이터셋으로의 전이 학습은 경쟁력 있거나 state-of-the-art 결과를 달성하여 더 나은 ImageNet 모델이 더 잘 전이된다는 일반 원칙을 확증합니다. CIFAR-10 결과 99.0%(98.5%에서) 및 CIFAR-100 결과 91.3%(89.3%에서)가 특히 주목할 만합니다.

| 데이터셋 | GPipe 정확도 | 이전 최고 |
|---|---|---|
| ImageNet-2012 | **84.4%** | 83.9% |
| CIFAR-10 | **99.0%** | 98.5% |
| CIFAR-100 | **91.3%** | 89.3% |
| Stanford Cars | 94.6% | 94.8% |
| Oxford Pets | **95.9%** | 93.8% |
| Food-101 | **93.0%** | 90.4% |
| Birdsnap | **83.6%** | 80.2% |

**다국어 NMT.** 번역 실험은 가장 흥미로운 발견 중 일부를 제공합니다. 400M에서 60억 파라미터로 스케일링하면 모든 102개 언어에서 일관된 개선이 나타납니다. 13억 파라미터 깊은 모델 $T(24, 8192, 16)$과 13억 파라미터 넓은 모델 $T(12, 16384, 32)$를 비교하는 깊이-너비 트레이드오프 분석은 깊이가 저자원 언어에 대해 너비보다 더 유익함을 보여주며, 이는 깊이가 교차 언어 전이 능력을 증가시킴을 시사합니다. 배치 크기를 260K에서 4M 토큰으로 증가시키면 독일어-영어에서 BLEU가 30.92에서 32.71로 향상되어 GPipe의 데이터 병렬화와의 호환성이 추가 스케일링 이점을 가능하게 함을 보여줍니다. 결정적으로, 60억 파라미터 다국어 모델은 모든 100개 이상의 언어 쌍에서 전용 bilingual Transformer Big 베이스라인을 능가하며, 이는 충분한 모델 용량이 다국어 학습에서 일반적으로 관찰되는 간섭을 극복할 수 있음을 보여주는 획기적인 결과입니다.

기여와 실험 결과 간의 연결은 긴밀합니다. 확장성 결과는 거대 모델 학습을 가능하게 한다는 핵심 주장을 직접 입증합니다. 효율성 결과는 마이크로 배치 파이프라이닝 알고리즘의 버블 오버헤드 최소화 능력을 검증합니다. 다운스트림 작업 결과는 활성화된 모델 스케일링이 의미 있는 품질 개선으로 이어짐을 확인합니다. 통신 오버헤드 실험은 하드웨어 요구 사항에 대한 실용적 우려를 다룹니다. 한 가지 주목할 만한 격차는 통제된 조건에서 PipeDream 또는 Mesh-TensorFlow와의 직접 비교가 없다는 것이지만, 섹션 6의 정성적 비교는 유익합니다.

## 4. Critical Assessment

### Strengths

1. 접근법의 단순성과 일반성이 놀랍습니다. 순차적 레이어로 표현 가능한 모든 네트워크는 세 가지 사용자 지정 파라미터($K$, $M$ 및 레이어 정의)만으로 병렬화될 수 있어, 분산 시스템 전문 지식 없이 실무자가 GPipe에 접근할 수 있습니다.
2. 동기식 gradient 업데이트 보장은 PipeDream과 같은 비동기 대안에 비해 주요 장점입니다. 이는 학습 동작이 병렬화 구성에 불변임을 의미하며, 하이퍼파라미터 민감도와 디버깅 복잡성의 원인을 제거합니다.
3. 실험적 평가는 두 가지 근본적으로 다른 아키텍처(convolutional AmoebaNet 및 Transformer)를 두 가지 구별되는 작업(이미지 분류 및 NMT)에 걸쳐 다루어 주장된 유연성을 설득력 있게 입증합니다.
4. 통신 효율성이 잘 입증되어 고속 인터커넥트가 없는 GPU에서도 거의 선형적인 스케일링을 보여주며, 상용 하드웨어에 대한 적용 가능성을 넓힙니다.
5. 다국어 NMT 결과는 모델 용량이 다국어 학습의 중요한 병목임을 보여주는 설득력 있는 증거를 제공하며, 60억 파라미터 모델은 100개 이상의 언어에서 bilingual 베이스라인을 능가하는 최초의 모델입니다.

### Limitations

1. GPipe는 각 개별 레이어가 단일 가속기의 메모리 내에 맞아야 한다고 가정합니다. 매우 큰 개별 레이어(예: 거대한 임베딩 테이블 또는 극단적인 시퀀스 길이를 가진 attention 레이어)를 가진 아키텍처의 경우, 이는 논문이 간략하게만 인정하는 제약 조건입니다.
2. 마이크로 배치 분할은 배치 차원에 걸쳐 통계를 계산하는 레이어(예: batch normalization)에 복잡성을 야기합니다. 논문의 마이크로 배치당 통계 계산 솔루션은 학습과 평가 중에 사용되는 전체 배치 통계 간에 불일치를 도입합니다.
3. 파이프라인 버블 오버헤드 공식 $O(\frac{K-1}{M+K-1})$는 효율성을 유지하려면 $M$이 $K$에 비례하여 증가해야 함을 의미합니다. 이는 최소 효과적 배치 크기를 제한하며, 최적화 이유로 더 작은 배치 크기가 바람직한 작업과 잠재적으로 충돌할 수 있습니다.
4. 파티셔닝 알고리즘은 휴리스틱 비용 추정기를 사용하여 비용 분산을 최소화하지만, 성능이 파티셔닝 품질에 얼마나 민감한지에 대한 분석이나 휴리스틱 접근법 이상의 대안적 파티셔닝 전략은 탐구되지 않았습니다.
5. 통제된 실험 조건에서 동시대 파이프라인 병렬화 접근법(PipeDream) 또는 SPMD 접근법(Mesh-TensorFlow)과의 직접적인 실험적 비교가 없습니다. 섹션 6의 비교는 순전히 정성적입니다.

### Future Directions

1. 파이프라인 병렬화를 텐서/SPMD 병렬화와 결합하면 교차 레이어 차원에 대한 통신 효율성을 유지하면서 단일 레이어 메모리 제한을 극복할 수 있습니다.
2. 적응적 또는 동적 마이크로 배치 크기 조정은 학습 중 버블 오버헤드와 메모리 소비 간의 트레이드오프를 최적화할 수 있으며, 계산 요구 사항이 변경됨에 따라 $M$을 조정할 수 있습니다.
3. 파이프라인 병렬화를 비순차적 아키텍처(예: 여러 파티션에 걸친 skip connection이 있는 네트워크 또는 다중 분기 아키텍처)로 확장하면 U-Net과 같은 현대 아키텍처에 대한 적용 가능성이 넓어질 수 있습니다.
4. 마이크로 배치 분할과 gradient 노이즈 간의 상호 작용을 조사하면 더 작은 마이크로 배치에 의해 도입된 암시적 gradient 노이즈가 정규화 이점을 제공하는지 또는 수렴을 해치는지 밝혀낼 수 있습니다.
5. GPipe의 원칙을 학습뿐만 아니라 추론 시간 모델 병렬화에 적용하면 상용 하드웨어에서 단일 디바이스 메모리를 초과하는 모델을 서빙할 수 있습니다.

---
